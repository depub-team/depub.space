{"ast":null,"code":"var dataUriPattern = /^data:/;\nexport var ImageUriCache = function () {\n  function ImageUriCache() {}\n\n  ImageUriCache.has = function has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  };\n\n  ImageUriCache.add = function add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp: lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  };\n\n  ImageUriCache.remove = function remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    }\n\n    ImageUriCache._cleanUpIfNeeded();\n  };\n\n  ImageUriCache._cleanUpIfNeeded = function _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(function (uri) {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  };\n\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;\n;\n\nvar _a, _b;\n\nif (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n  var currentExports = module.__proto__.exports;\n  var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n  self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n\n  if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n    module.hot.dispose(function (data) {\n      data.prevExports = currentExports;\n    });\n    module.hot.accept();\n\n    if (prevExports !== null) {\n      if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n        module.hot.invalidate();\n      } else {\n        self.$RefreshHelpers$.scheduleUpdate();\n      }\n    }\n  } else {\n    var isNoLongerABoundary = prevExports !== null;\n\n    if (isNoLongerABoundary) {\n      module.hot.invalidate();\n    }\n  }\n}","map":{"version":3,"sources":["/media/disk1/projects/depub.space/node_modules/react-native-web/dist/modules/ImageLoader/index.js"],"names":["dataUriPattern","ImageUriCache","entries","isDataUri","Boolean","lastUsedTimestamp","Date","refCount","imageUris","Object","entry","leastRecentlyUsedEntry","leastRecentlyUsedKey","id","requests","ImageLoader","abort","image","getSize","complete","interval","setInterval","requestId","naturalHeight","naturalWidth","success","clearInterval","failure","has","load","window","onDecode","onLoad","nativeEvent","setTimeout","prefetch","resolve","queryCache","result","uris","Promise"],"mappings":"AAQA,IAAIA,cAAc,GAAlB,QAAA;AACA,OAAO,IAAIC,aAAa,GAAgB,YAAY;AAClD,WAAA,aAAA,GAAyB,CAEzBA;;AAAAA,EAAAA,aAAa,CAAbA,GAAAA,GAAoB,SAAA,GAAA,CAAA,GAAA,EAAkB;AACpC,QAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;AACA,QAAIE,SAAS,GAAGH,cAAc,CAAdA,IAAAA,CAAhB,GAAgBA,CAAhB;AACA,WAAOG,SAAS,IAAIC,OAAO,CAACF,OAAO,CAAnC,GAAmC,CAAR,CAA3B;AAHFD,GAAAA;;AAMAA,EAAAA,aAAa,CAAbA,GAAAA,GAAoB,SAAA,GAAA,CAAA,GAAA,EAAkB;AACpC,QAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;AACA,QAAII,iBAAiB,GAAGC,IAAI,CAA5B,GAAwBA,EAAxB;;AAEA,QAAIJ,OAAO,CAAX,GAAW,CAAX,EAAkB;AAChBA,MAAAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,iBAAAA,GAAAA,iBAAAA;AACAA,MAAAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,QAAAA,IAAAA,CAAAA;AAFF,KAAA,MAGO;AACLA,MAAAA,OAAO,CAAPA,GAAO,CAAPA,GAAe;AACbG,QAAAA,iBAAiB,EADJ,iBAAA;AAEbE,QAAAA,QAAQ,EAFVL;AAAe,OAAfA;AAKH;AAbDD,GAAAA;;AAeAA,EAAAA,aAAa,CAAbA,MAAAA,GAAuB,SAAA,MAAA,CAAA,GAAA,EAAqB;AAC1C,QAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;;AAEA,QAAIC,OAAO,CAAX,GAAW,CAAX,EAAkB;AAChBA,MAAAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,QAAAA,IAAAA,CAAAA;AAIFD;;AAAAA,IAAAA,aAAa,CAAbA,gBAAAA;AARFA,GAAAA;;AAWAA,EAAAA,aAAa,CAAbA,gBAAAA,GAAiC,SAAA,gBAAA,GAA4B;AAC3D,QAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;AACA,QAAIO,SAAS,GAAGC,MAAM,CAANA,IAAAA,CAAhB,OAAgBA,CAAhB;;AAEA,QAAID,SAAS,CAATA,MAAAA,GAAAA,CAAAA,GAAuBP,aAAa,CAAxC,eAAA,EAA0D;AACxD,UAAA,oBAAA;AACA,UAAA,sBAAA;AACAO,MAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,GAAA,EAAe;AAC/B,YAAIE,KAAK,GAAGR,OAAO,CAAnB,GAAmB,CAAnB;;AAEA,YAAI,CAAC,CAAA,sBAAA,IAA2BQ,KAAK,CAALA,iBAAAA,GAA0BC,sBAAsB,CAA5E,iBAAA,KAAmGD,KAAK,CAALA,QAAAA,KAAvG,CAAA,EAA6H;AAC3HE,UAAAA,oBAAoB,GAApBA,GAAAA;AACAD,UAAAA,sBAAsB,GAAtBA,KAAAA;AAEH;AAPDH,OAAAA;;AASA,UAAA,oBAAA,EAA0B;AACxB,eAAON,OAAO,CAAd,oBAAc,CAAd;AAEH;AACF;AApBDD,GAAAA;;AAsBA,SAAA,aAAA;AAzDK,CAAiC,EAAjC;AA2DPA,aAAa,CAAbA,eAAAA,GAAAA,GAAAA;AACAA,aAAa,CAAbA,QAAAA,GAAAA,EAAAA;AACA,IAAIY,EAAE,GAAN,CAAA;AACA,IAAIC,QAAQ,GAAZ,EAAA;AACA,IAAIC,WAAW,GAAG;AAChBC,EAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,SAAA,EAA0B;AAC/B,QAAIC,KAAK,GAAGH,QAAQ,CAAC,KAArB,SAAoB,CAApB;;AAEA,QAAA,KAAA,EAAW;AACTG,MAAAA,KAAK,CAALA,OAAAA,GAAAA,IAAAA;AACAA,MAAAA,KAAK,CAALA,MAAAA,GAAAA,IAAAA;AACAA,MAAAA,KAAK,GAALA,IAAAA;AACA,aAAOH,QAAQ,CAAC,KAAhB,SAAe,CAAf;AAEH;AAVe,GAAA;AAWhBI,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,GAAA,EAAA,OAAA,EAAA,OAAA,EAAwC;AAC/C,QAAIC,QAAQ,GAAZ,KAAA;AACA,QAAIC,QAAQ,GAAGC,WAAW,CAAA,QAAA,EAA1B,EAA0B,CAA1B;AACA,QAAIC,SAAS,GAAGP,WAAW,CAAXA,IAAAA,CAAAA,GAAAA,EAAAA,QAAAA,EAAhB,aAAgBA,CAAhB;;AAEA,aAAA,QAAA,GAAoB;AAClB,UAAIE,KAAK,GAAGH,QAAQ,CAAC,KAArB,SAAoB,CAApB;;AAEA,UAAA,KAAA,EAAW;AACT,YAAIS,aAAa,GAAGN,KAAK,CAAzB,aAAA;AAAA,YACIO,YAAY,GAAGP,KAAK,CADxB,YAAA;;AAGA,YAAIM,aAAa,IAAjB,YAAA,EAAmC;AACjCE,UAAAA,OAAO,CAAA,YAAA,EAAPA,aAAO,CAAPA;AACAN,UAAAA,QAAQ,GAARA,IAAAA;AAEH;AAED;;AAAA,UAAA,QAAA,EAAc;AACZJ,QAAAA,WAAW,CAAXA,KAAAA,CAAAA,SAAAA;AACAW,QAAAA,aAAa,CAAbA,QAAa,CAAbA;AAEH;AAED;;AAAA,aAAA,aAAA,GAAyB;AACvB,UAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;AACjCC,QAAAA,OAAO;AAGTZ;;AAAAA,MAAAA,WAAW,CAAXA,KAAAA,CAAAA,SAAAA;AACAW,MAAAA,aAAa,CAAbA,QAAa,CAAbA;AAEH;AA3Ce,GAAA;AA4ChBE,EAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,GAAA,EAAkB;AACrB,WAAO3B,aAAa,CAAbA,GAAAA,CAAP,GAAOA,CAAP;AA7Cc,GAAA;AA+ChB4B,EAAAA,IAAI,EAAE,SAAA,IAAA,CAAA,GAAA,EAAA,MAAA,EAAA,OAAA,EAAoC;AACxChB,IAAAA,EAAE,IAAFA,CAAAA;AACA,QAAII,KAAK,GAAG,IAAIa,MAAM,CAAtB,KAAY,EAAZ;AACAb,IAAAA,KAAK,CAALA,OAAAA,GAAAA,OAAAA;;AAEAA,IAAAA,KAAK,CAALA,MAAAA,GAAe,UAAA,CAAA,EAAa;AAE1B,UAAIc,QAAQ,GAAG,SAAA,QAAA,GAAoB;AACjC,eAAOC,MAAM,CAAC;AACZC,UAAAA,WAAW,EADb;AAAc,SAAD,CAAb;AADF,OAAA;;AAMA,UAAI,OAAOhB,KAAK,CAAZ,MAAA,KAAJ,UAAA,EAAwC;AAItCA,QAAAA,KAAK,CAALA,MAAAA,GAAAA,IAAAA,CAAAA,QAAAA,EAAAA,QAAAA;AAJF,OAAA,MAKO;AACLiB,QAAAA,UAAU,CAAA,QAAA,EAAVA,CAAU,CAAVA;AAEH;AAhBDjB,KAAAA;;AAkBAA,IAAAA,KAAK,CAALA,GAAAA,GAAAA,GAAAA;AACAH,IAAAA,QAAQ,CAAC,KAATA,EAAQ,CAARA,GAAAA,KAAAA;AACA,WAAA,EAAA;AAxEc,GAAA;AA0EhBqB,EAAAA,QAAQ,EAAE,SAAA,QAAA,CAAA,GAAA,EAAuB;AAC/B,WAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAA2B;AAC5CpB,MAAAA,WAAW,CAAXA,IAAAA,CAAAA,GAAAA,EAAsB,YAAY;AAGhCd,QAAAA,aAAa,CAAbA,GAAAA,CAAAA,GAAAA;AACAA,QAAAA,aAAa,CAAbA,MAAAA,CAAAA,GAAAA;AACAmC,QAAAA,OAAO;AALTrB,OAAAA,EAAAA,MAAAA;AADF,KAAO,CAAP;AA3Ec,GAAA;AAqFhBsB,EAAAA,UAAU,EAAE,SAAA,UAAA,CAAA,IAAA,EAA0B;AACpC,QAAIC,MAAM,GAAV,EAAA;AACAC,IAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,CAAA,EAAa;AACxB,UAAItC,aAAa,CAAbA,GAAAA,CAAJ,CAAIA,CAAJ,EAA0B;AACxBqC,QAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,aAAAA;AAEH;AAJDC,KAAAA;AAKA,WAAOC,OAAO,CAAPA,OAAAA,CAAP,MAAOA,CAAP;AA5FJ;AAAkB,CAAlB;AA+FA,eAAA,WAAA","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\nexport var ImageUriCache = /*#__PURE__*/function () {\n  function ImageUriCache() {}\n\n  ImageUriCache.has = function has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  };\n\n  ImageUriCache.add = function add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp: lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  };\n\n  ImageUriCache.remove = function remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  };\n\n  ImageUriCache._cleanUpIfNeeded = function _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(function (uri) {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  };\n\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      // avoid blocking the main thread\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;"]},"metadata":{},"sourceType":"module"}