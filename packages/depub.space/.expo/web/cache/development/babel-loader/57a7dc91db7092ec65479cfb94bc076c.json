{"ast":null,"code":"'use strict';\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\n_c = A;\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\n_c2 = B;\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\n\n_c3 = C;\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"A\");\n$RefreshReg$(_c2, \"B\");\n$RefreshReg$(_c3, \"C\");\n;\n\nvar _a, _b;\n\nif (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n  var currentExports = module.__proto__.exports;\n  var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n  self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n\n  if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n    module.hot.dispose(function (data) {\n      data.prevExports = currentExports;\n    });\n    module.hot.accept();\n\n    if (prevExports !== null) {\n      if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n        module.hot.invalidate();\n      } else {\n        self.$RefreshHelpers$.scheduleUpdate();\n      }\n    }\n  } else {\n    var isNoLongerABoundary = prevExports !== null;\n\n    if (isNoLongerABoundary) {\n      module.hot.invalidate();\n    }\n  }\n}","map":{"version":3,"sources":["/media/disk1/projects/depub.space/node_modules/react-native-web/dist/vendor/react-native/Animated/bezier.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","A","B","C","i","aA","aB","currentT","currentX","calcBezier","Math","aGuessT","currentSlope","getSlope","mX1","mX2","sampleValues","intervalStart","currentSample","lastSample","dist","aX","guessForT","initialSlope","newtonRaphsonIterate","binarySubdivide","x","getTForX"],"mappings":"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","sourcesContent":["/**\n * Portions Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n/**\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n * @copyright 2014-2015 GaÃ«tan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;"]},"metadata":{},"sourceType":"module"}