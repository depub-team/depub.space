{"ast":null,"code":"import { useEffect, useRef } from \"react\";\nimport { useFocusable } from \"@react-aria/focus\";\nimport { useField } from \"@react-aria/label\";\nimport { filterDOMProps, mergeProps } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nexport function useTextField(props, ref) {\n  var _props$inputElementTy = props.inputElementType,\n      inputElementType = _props$inputElementTy === void 0 ? 'input' : _props$inputElementTy,\n      _props$isDisabled = props.isDisabled,\n      isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,\n      _props$isRequired = props.isRequired,\n      isRequired = _props$isRequired === void 0 ? false : _props$isRequired,\n      _props$isReadOnly = props.isReadOnly,\n      isReadOnly = _props$isReadOnly === void 0 ? false : _props$isReadOnly,\n      validationState = props.validationState,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      _props$onChange = props.onChange,\n      _onChange = _props$onChange === void 0 ? function () {} : _props$onChange;\n\n  var _useFocusable = useFocusable(props, ref),\n      focusableProps = _useFocusable.focusableProps;\n\n  var _useField = useField(props),\n      labelProps = _useField.labelProps,\n      fieldProps = _useField.fieldProps,\n      descriptionProps = _useField.descriptionProps,\n      errorMessageProps = _useField.errorMessageProps;\n\n  var domProps = filterDOMProps(props, {\n    labelable: true\n  });\n  var inputOnlyProps = {\n    type: type,\n    pattern: props.pattern\n  };\n  return {\n    labelProps: labelProps,\n    inputProps: mergeProps(domProps, inputElementType === 'input' && inputOnlyProps, _babelRuntimeHelpersEsmExtends({\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-activedescendant': props['aria-activedescendant'],\n      'aria-autocomplete': props['aria-autocomplete'],\n      'aria-haspopup': props['aria-haspopup'],\n      value: props.value,\n      defaultValue: props.value ? undefined : props.defaultValue,\n      onChange: function onChange(e) {\n        return _onChange(e.target.value);\n      },\n      autoComplete: props.autoComplete,\n      maxLength: props.maxLength,\n      minLength: props.minLength,\n      name: props.name,\n      placeholder: props.placeholder,\n      inputMode: props.inputMode,\n      onCopy: props.onCopy,\n      onCut: props.onCut,\n      onPaste: props.onPaste,\n      onCompositionEnd: props.onCompositionEnd,\n      onCompositionStart: props.onCompositionStart,\n      onCompositionUpdate: props.onCompositionUpdate,\n      onSelect: props.onSelect,\n      onBeforeInput: props.onBeforeInput,\n      onInput: props.onInput\n    }, focusableProps, fieldProps)),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nfunction $c7e32867b2abc7e2d776d5c060056cb7$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' && window.InputEvent && typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nexport function useFormattedTextField(props, state, inputRef) {\n  var stateRef = useRef(state);\n  stateRef.current = state;\n  useEffect(function () {\n    if (!$c7e32867b2abc7e2d776d5c060056cb7$var$supportsNativeBeforeInputEvent()) {\n      return;\n    }\n\n    var input = inputRef.current;\n\n    var onBeforeInput = function onBeforeInput(e) {\n      var state = stateRef.current;\n      var nextValue;\n\n      switch (e.inputType) {\n        case 'historyUndo':\n        case 'historyRedo':\n          return;\n\n        case 'deleteContent':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentForward':\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentBackward':\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteSoftLineBackward':\n        case 'deleteHardLineBackward':\n          nextValue = input.value.slice(input.selectionStart);\n          break;\n\n        default:\n          if (e.data != null) {\n            nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n          }\n\n          break;\n      }\n\n      if (nextValue == null || !state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    };\n\n    input.addEventListener('beforeinput', onBeforeInput, false);\n    return function () {\n      input.removeEventListener('beforeinput', onBeforeInput, false);\n    };\n  }, [inputRef, stateRef]);\n  var onBeforeInput = !$c7e32867b2abc7e2d776d5c060056cb7$var$supportsNativeBeforeInputEvent() ? function (e) {\n    var nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n\n    if (!state.validate(nextValue)) {\n      e.preventDefault();\n    }\n  } : null;\n\n  var _useTextField = useTextField(props, inputRef),\n      labelProps = _useTextField.labelProps,\n      textFieldProps = _useTextField.inputProps,\n      descriptionProps = _useTextField.descriptionProps,\n      errorMessageProps = _useTextField.errorMessageProps;\n\n  var compositionStartState = useRef(null);\n  return {\n    inputProps: mergeProps(textFieldProps, {\n      onBeforeInput: onBeforeInput,\n      onCompositionStart: function onCompositionStart() {\n        var _inputRef$current = inputRef.current,\n            value = _inputRef$current.value,\n            selectionStart = _inputRef$current.selectionStart,\n            selectionEnd = _inputRef$current.selectionEnd;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n      onCompositionEnd: function onCompositionEnd() {\n        if (!state.validate(inputRef.current.value)) {\n          var _compositionStartStat = compositionStartState.current,\n              value = _compositionStartStat.value,\n              selectionStart = _compositionStartStat.selectionStart,\n              selectionEnd = _compositionStartStat.selectionEnd;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state.setInputValue(value);\n        }\n      }\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/textfield/src/useTextField.ts","packages/@react-aria/textfield/src/useFormattedTextField.ts"],"names":["inputElementType","isDisabled","isRequired","isReadOnly","type","onChange","focusableProps","useFocusable","errorMessageProps","useField","domProps","filterDOMProps","labelable","inputOnlyProps","pattern","props","labelProps","inputProps","mergeProps","disabled","readOnly","validationState","value","defaultValue","e","autoComplete","maxLength","minLength","name","placeholder","inputMode","onCopy","onCut","onPaste","onCompositionEnd","onCompositionStart","onCompositionUpdate","onSelect","onBeforeInput","onInput","descriptionProps","window","InputEvent","stateRef","useRef","useEffect","supportsNativeBeforeInputEvent","input","inputRef","state","nextValue","compositionStartState","selectionEnd","selectionStart"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTextFieldProps} from '@react-types/textfield';\nimport {\n  ChangeEvent,\n  DOMFactory,\n  HTMLAttributes,\n  LabelHTMLAttributes,\n  ReactDOM,\n  RefObject\n} from 'react';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {useField} from '@react-aria/label';\nimport {useFocusable} from '@react-aria/focus';\n\n/**\n * A map of HTML element names and their interface types.\n * For example `'a'` -> `HTMLAnchorElement`.\n */\ntype IntrinsicHTMLElements = {\n  [K in keyof IntrinsicHTMLAttributes]: IntrinsicHTMLAttributes[K] extends HTMLAttributes<infer T> ? T : never\n};\n\n/**\n * A map of HTML element names and their attribute interface types.\n * For example `'a'` -> `AnchorHTMLAttributes<HTMLAnchorElement>`.\n */\ntype IntrinsicHTMLAttributes = {\n  [K in keyof ReactDOM]: ReactDOM[K] extends DOMFactory<infer T, any> ? T : never\n};\n\ntype DefaultElementType = 'input';\n\n/**\n * The intrinsic HTML element names that `useTextField` supports; e.g. `input`,\n * `textarea`.\n */\ntype TextFieldIntrinsicElements = keyof Pick<IntrinsicHTMLElements, 'input' | 'textarea'>;\n\n /**\n  * The HTML element interfaces that `useTextField` supports based on what is\n  * defined for `TextFieldIntrinsicElements`; e.g. `HTMLInputElement`,\n  * `HTMLTextAreaElement`.\n  */\ntype TextFieldHTMLElementType = Pick<IntrinsicHTMLElements, TextFieldIntrinsicElements>;\n\n /**\n  * The HTML attributes interfaces that `useTextField` supports based on what\n  * is defined for `TextFieldIntrinsicElements`; e.g. `InputHTMLAttributes`,\n  * `TextareaHTMLAttributes`.\n  */\ntype TextFieldHTMLAttributesType = Pick<IntrinsicHTMLAttributes, TextFieldIntrinsicElements>;\n\n/**\n * The type of `inputProps` returned by `useTextField`; e.g. `InputHTMLAttributes`,\n * `TextareaHTMLAttributes`.\n */\ntype TextFieldInputProps<T extends TextFieldIntrinsicElements> = TextFieldHTMLAttributesType[T];\n\ninterface AriaTextFieldOptions<T extends TextFieldIntrinsicElements> extends AriaTextFieldProps {\n  /**\n   * The HTML element used to render the input, e.g. 'input', or 'textarea'.\n   * It determines whether certain HTML attributes will be included in `inputProps`.\n   * For example, [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type).\n   * @default 'input'\n   */\n  inputElementType?: T\n}\n\n/**\n * The type of `ref` object that can be passed to `useTextField` based on the given\n * intrinsic HTML element name; e.g.`RefObject<HTMLInputElement>`,\n * `RefObject<HTMLTextAreaElement>`.\n */\ntype TextFieldRefObject<T extends TextFieldIntrinsicElements> = RefObject<TextFieldHTMLElementType[T]>;\n\nexport interface TextFieldAria<T extends TextFieldIntrinsicElements = DefaultElementType> {\n  /** Props for the input element. */\n  inputProps: TextFieldInputProps<T>,\n  /** Props for the text field's visible label element, if any. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n  /** Props for the text field's description element, if any. */\n  descriptionProps: HTMLAttributes<HTMLElement>,\n  /** Props for the text field's error message element, if any. */\n  errorMessageProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a text field.\n * @param props - Props for the text field.\n * @param ref - Ref to the HTML input or textarea element.\n */\nexport function useTextField<T extends TextFieldIntrinsicElements = DefaultElementType>(\n  props: AriaTextFieldOptions<T>,\n  ref: TextFieldRefObject<T>\n): TextFieldAria<T> {\n  let {\n    inputElementType = 'input',\n    isDisabled = false,\n    isRequired = false,\n    isReadOnly = false,\n    validationState,\n    type = 'text',\n    onChange = () => {}\n  }: AriaTextFieldOptions<TextFieldIntrinsicElements> = props;\n  let {focusableProps} = useFocusable(props, ref);\n  let {labelProps, fieldProps, descriptionProps, errorMessageProps} = useField(props);\n  let domProps = filterDOMProps(props, {labelable: true});\n\n  const inputOnlyProps = {\n    type,\n    pattern: props.pattern\n  };\n\n  return {\n    labelProps,\n    inputProps: mergeProps(\n      domProps,\n      inputElementType === 'input' && inputOnlyProps,\n      {\n        disabled: isDisabled,\n        readOnly: isReadOnly,\n        'aria-required': isRequired || undefined,\n        'aria-invalid': validationState === 'invalid' || undefined,\n        'aria-errormessage': props['aria-errormessage'],\n        'aria-activedescendant': props['aria-activedescendant'],\n        'aria-autocomplete': props['aria-autocomplete'],\n        'aria-haspopup': props['aria-haspopup'],\n        value: props.value,\n        defaultValue: props.value ? undefined : props.defaultValue,\n        onChange: (e: ChangeEvent<HTMLInputElement>) => onChange(e.target.value),\n        autoComplete: props.autoComplete,\n        maxLength: props.maxLength,\n        minLength: props.minLength,\n        name: props.name,\n        placeholder: props.placeholder,\n        inputMode: props.inputMode,\n\n        // Clipboard events\n        onCopy: props.onCopy,\n        onCut: props.onCut,\n        onPaste: props.onPaste,\n\n        // Composition events\n        onCompositionEnd: props.onCompositionEnd,\n        onCompositionStart: props.onCompositionStart,\n        onCompositionUpdate: props.onCompositionUpdate,\n\n        // Selection events\n        onSelect: props.onSelect,\n\n        // Input events\n        onBeforeInput: props.onBeforeInput,\n        onInput: props.onInput,\n        ...focusableProps,\n        ...fieldProps\n      }\n    ),\n    descriptionProps,\n    errorMessageProps\n  };\n}\n","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTextFieldProps} from '@react-types/textfield';\nimport {mergeProps} from '@react-aria/utils';\nimport {RefObject, useEffect, useRef} from 'react';\nimport {TextFieldAria, useTextField} from './useTextField';\n\ninterface FormattedTextFieldState {\n  validate: (val: string) => boolean,\n  setInputValue: (val: string) => void\n}\n\n\nfunction supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' &&\n    window.InputEvent &&\n    // @ts-ignore\n    typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nexport function useFormattedTextField(props: AriaTextFieldProps, state: FormattedTextFieldState, inputRef: RefObject<HTMLInputElement>): TextFieldAria {\n\n  let stateRef = useRef(state);\n  stateRef.current = state;\n\n  // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n  useEffect(() => {\n    if (!supportsNativeBeforeInputEvent()) {\n      return;\n    }\n\n    let input = inputRef.current;\n\n    let onBeforeInput = (e: InputEvent) => {\n      let state = stateRef.current;\n\n      // Compute the next value of the input if the event is allowed to proceed.\n      // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n      let nextValue: string;\n      switch (e.inputType) {\n        case 'historyUndo':\n        case 'historyRedo':\n          // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n          // because presumably the input would have already been validated previously.\n          return;\n        case 'deleteContent':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteContentForward':\n          // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n          // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n          // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n          // If we support additional locales in the future, this may need to change.\n          nextValue = input.selectionEnd === input.selectionStart\n            ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1)\n            : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteContentBackward':\n          nextValue = input.selectionEnd === input.selectionStart\n            ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart)\n            : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteSoftLineBackward':\n        case 'deleteHardLineBackward':\n          nextValue = input.value.slice(input.selectionStart);\n          break;\n        default:\n          if (e.data != null) {\n            nextValue =\n              input.value.slice(0, input.selectionStart) +\n              e.data +\n              input.value.slice(input.selectionEnd);\n          }\n          break;\n      }\n\n      // If we did not compute a value, or the new value is invalid, prevent the event\n      // so that the browser does not update the input text, move the selection, or add to\n      // the undo/redo stack.\n      if (nextValue == null || !state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    };\n\n    input.addEventListener('beforeinput', onBeforeInput, false);\n    return () => {\n      input.removeEventListener('beforeinput', onBeforeInput, false);\n    };\n  }, [inputRef, stateRef]);\n\n  let onBeforeInput = !supportsNativeBeforeInputEvent()\n    ? e => {\n      let nextValue =\n        e.target.value.slice(0, e.target.selectionStart) +\n        e.data +\n        e.target.value.slice(e.target.selectionEnd);\n\n      if (!state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    }\n    : null;\n\n  let {labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps} = useTextField(props, inputRef);\n\n  let compositionStartState = useRef(null);\n  return {\n    inputProps: mergeProps(\n      textFieldProps,\n      {\n        onBeforeInput,\n        onCompositionStart() {\n          // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n          // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n          // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n          // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n          // nor would we want to cancel them because the input from the user is incomplete at that point.\n          // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n          // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n          // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n          // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n          // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n          // are implemented, there is no other way to prevent composed input.\n          // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n          let {value, selectionStart, selectionEnd} = inputRef.current;\n          compositionStartState.current = {value, selectionStart, selectionEnd};\n        },\n        onCompositionEnd() {\n          if (!state.validate(inputRef.current.value)) {\n            // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n            // But also update the value in React state as well so it is correct for future updates.\n            let {value, selectionStart, selectionEnd} = compositionStartState.current;\n            inputRef.current.value = value;\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n            state.setInputValue(value);\n          }\n        }\n      }\n    ),\n    labelProps,\n    descriptionProps,\n    errorMessageProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}